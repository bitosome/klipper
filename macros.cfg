[gcode_macro _LOW_TEMP_CHECK]
description: Check the nozzle is at temperature and heat it if needed
gcode: 
    {% set T = params.T|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}

    {% if printer.extruder.target != 0 %}
        {% if printer.extruder.temperature < printer.extruder.target %}
            M109 S{printer.extruder.target|float} 
        {% endif %}
    {% else %}
        {% if printer.extruder.target < T %}
            M109 S{T}
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

# Monitoring loop for hotend fan safety check
[delayed_gcode _BACKGROUND_HOTEND_TACHO_CHECK]
gcode:
    _HOTEND_FAN_CHECK
    UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=3

# ═══════════════════════════════════════════════════════

[gcode_macro _HOTEND_FAN_CHECK]
description: Check the hotend fan tachometer to verify that it is running effectively
variable_he_stop_count: 0
gcode:
    {% set min_rpm = 1000|float %} # This is a relatively low value adapted to all fans to check that they are effectively running
    {% set max_consecutive_stops = 3 %}
    {% set rpm = printer['heater_fan hotend_fan'].rpm|float %}
    {% set he_target = printer[printer.toolhead.extruder].target|float %}
    {% set he_temp = printer[printer.toolhead.extruder].temperature|float %}
    {% set fan_on_temp = printer.configfile.settings['heater_fan hotend_fan'].heater_temp|float %}
    {% set he_stop_count = printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int %}

    {% if (he_target >= fan_on_temp) and (rpm < min_rpm) and (he_temp >= fan_on_temp) %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE={he_stop_count + 1}
        RESPOND MSG="Hotend fan stoppage detected for {(he_stop_count+1)*3}sec (max {max_consecutive_stops*3}sec allowed)"
        M400
        {% if printer["gcode_macro _HOTEND_FAN_CHECK"].he_stop_count|int >= max_consecutive_stops-1 %}
            CANCEL_PRINT
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_HOTEND_FAN_CHECK VARIABLE=he_stop_count VALUE=0
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _PART_FAN_CHECK]
description: Check the part fan tachometer to verify that it is running effectively
gcode:
    {% if printer.fan.rpm is not none %}
        {% if printer.fan.rpm > 1000 %} # This is a relatively low value adapted to all fans to check that they are effectively running
            {action_respond_info("Part fan OK!")}
        {% else %}
            M400
            CANCEL_PRINT
            {action_raise_error("Hotend fan stoppage detected, print was canceled!")}
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro PRIMELINE]
gcode:
    # Base macro parameters
    {% set prime_line_length = params.LINE_LENGTH|default(printer["gcode_macro _USER_VARIABLES"].prime_line_length)|float %}
    {% set prime_line_purge_distance = params.PURGE_LENGTH|default(printer["gcode_macro _USER_VARIABLES"].prime_line_purge_distance)|float %}
    {% set prime_line_flowrate = params.FLOWRATE|default(printer["gcode_macro _USER_VARIABLES"].prime_line_flowrate)|float %}
    {% set prime_line_height = params.LINE_HEIGHT|default(printer["gcode_macro _USER_VARIABLES"].prime_line_height)|default(0.6)|float %}
    {% set prime_line_adaptive = params.ADAPTIVE_MODE|default(1)|int %}
    {% set prime_line_margin = params.LINE_MARGIN|default(printer["gcode_macro _USER_VARIABLES"].prime_line_margin)|default(5.0)|float %} # Used only in adaptive mode
    
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}
    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    # We get the default prime line position parameters
    {% set prime_line_x, prime_line_y = printer["gcode_macro _USER_VARIABLES"].prime_line_xy|map('float') %}
    {% set prime_line_x = params.START_X|default(prime_line_x)|float %}
    {% set prime_line_y = params.START_Y|default(prime_line_y)|float %}
    {% set prime_line_direction = params.LINE_DIRECTION|default(printer["gcode_macro _USER_VARIABLES"].prime_line_direction)|string|upper %}

    {% set center_x, center_y = [printer.toolhead.axis_maximum.x / 2, printer.toolhead.axis_maximum.y / 2]|map("float") %}
    
    # If first layer coordinates are retrieved and adaptive mode is enabled, then we replace the coordinates to
    # do an adaptive purge while being careful to have the line stay on the bed when the first layer
    # is in an opposite bed quadrant than the prime line initial coordinates (due to mirrored coordinates from center axes)...
    {% if coordinatesFound and prime_line_adaptive == 1 %}
        {% set prime_line_x = 2*center_x - prime_line_x if (prime_line_x > center_x and xMaxSpec < center_x) or (prime_line_x < center_x and xMinSpec > center_x) 
                               else prime_line_x %}
        {% set prime_line_y = 2*center_y - prime_line_y if (prime_line_y > center_y and yMaxSpec < center_y) or (prime_line_y < center_y and yMinSpec > center_y) 
                               else prime_line_y %}
        {% set prime_line_x = [[prime_line_x, xMinSpec - prime_line_margin]|max, xMaxSpec + prime_line_margin]|min %}
        {% set prime_line_y = [[prime_line_y, yMinSpec - prime_line_margin]|max, yMaxSpec + prime_line_margin]|min %}
    {% endif %}

    # Choose the way of printing the primeline (in + or -) alongside the direction to avoid going outside the bed boundaries
    {% set prime_line_way = -1 if (prime_line_direction == "X" and prime_line_x > center_x) or (prime_line_direction == "Y" and prime_line_y > center_y) else 1 %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% set max_extrude_cross_section = printer["configfile"].config["extruder"]["max_extrude_cross_section"]|float %}
    {% set filament_diameter = printer["configfile"].config["extruder"]["filament_diameter"]|float %}
    
    # We first compute the width of the prime line
    {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
    {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}

    # Then we check that the prime line cross section will not be problematic (exceeding Klipper max_extrude_cross_section)
    # or, if it's the case, we warn the user and add a correction to the length of filament to be purged
    {% if (prime_line_height * line_width) > max_extrude_cross_section %}

        {action_respond_info("The prime_line_purge_distance of %.4f mm is too high and will exceed the max_extrude_cross_section!" % prime_line_purge_distance)}

        {% set prime_line_purge_distance = 0.98 * (max_extrude_cross_section * prime_line_length) / (3.14159 * (filament_diameter / 2)**2) %}
        {% set purge_volume = prime_line_purge_distance * 3.14159 * (filament_diameter / 2)**2 %}
        {% set line_width = purge_volume / (prime_line_height * prime_line_length) %}
        {action_respond_info("Klippain corrected the prime_line_purge_distance to %.4f mm" % prime_line_purge_distance)}

    {% endif %}

    # We then compute the height to width ratio and validate that the prime line will not be too thin
    {% if (prime_line_height / line_width) >= 0.5 %} # TODO: validate this 1/2 ratio is good for all
        {action_raise_error("The prime line will be too thin and will probably not stick properly to the bed. Increase its purge distance or decrease its length!")}
    {% endif %}

    # Finally we compute the speed to get the correct flowrate for the prime line
    {% set speed = (prime_line_flowrate / (prime_line_height * line_width)) * 60 |float %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
        {% endif %}
    {% endif %}

    G91
    M83
    {% if (printer.toolhead.position.z < 5) %}
        G1 Z5 F{Sz}
    {% endif %}

    # Starting position
    G90
    G0 X{prime_line_x} Y{prime_line_y} F{St}
    G1 Z{prime_line_height} F{Sz|int / 2}

    # Add pressure in the nozzle
    G92 E0
    G1 E18 F300

    # Prime line
    G92 E0
    {% if prime_line_direction == "X" %}
        G1 X{prime_line_x + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% elif prime_line_direction == "Y" %}
        G1 Y{prime_line_y + prime_line_way*prime_line_length} E{prime_line_purge_distance} F{speed}
    {% else %}
        { action_respond_error("Prime line direction is not valid. Choose either X or Y in the variables.cfg file!") }
    {% endif %}

    # Retract and Z-hop
    G92 E0
    G1 E-0.2 F2100
    G92 E0
    G1 Z3 F{Sz}

    # Additional small movement to get out of the line as some slicers directly emmit
    # a Z- move as a first step that make the toolhead crash back in the line and get dirty
    G91
    G1 X2 Y2 F{St}
    G90
    
    # Flushing Klipper's buffer to ensure the primeline sequence is done before continuing
    M400

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro CLEAN_NOZZLE]
description: Wipe the nozzle on the brush
gcode:
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set purgeclean_servo_enabled = printer["gcode_macro _USER_VARIABLES"].purgeclean_servo_enabled %}
    {% set brush_clean_accel = printer["gcode_macro _USER_VARIABLES"].brush_clean_accel %}
    {% set brush_over_y_axis = printer["gcode_macro _USER_VARIABLES"].brush_over_y_axis %}
    {% set brush_offset = printer["gcode_macro _USER_VARIABLES"].brush_center_offset|default(0)|float %}
    {% set brush_size = printer["gcode_macro _USER_VARIABLES"].brush_width_x|default(40)|float %}
    {% set brushes = printer["gcode_macro _USER_VARIABLES"].brushes|default(6)|int %}

    {% if purge_and_brush_enabled %}
        {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
        {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
        {% set Sc = printer["gcode_macro _USER_VARIABLES"].brush_clean_speed * 60 %}

        {% set Bx, By, Bz = printer["gcode_macro _USER_VARIABLES"].brush_xyz|map('float') %}
        {% set Bx = Bx + brush_offset %}

        STATUS_LEDS COLOR="CLEANING"

        RESPOND MSG="Nozzle cleaning..."

        # Set the cleaning acceleration prior to any movement
        {% set saved_accel = printer.toolhead.max_accel %}
        SET_VELOCITY_LIMIT ACCEL={brush_clean_accel}

        # Move to purge zone (left side)
        G90
        _CONDITIONAL_MOVE_TO_PURGE_BUCKET Z_DROP=1
        # Move to center of the brush
        G1 X{Bx} Y{By} F{St}
        G1 Z{Bz} F{St}
        # Wipe procedure
        G91
        {% if brush_over_y_axis %}
            {% for wipe in range(brushes) %}
                G1 Y-5 F{Sc}
                G1 Y+5 F{Sc}
            {% endfor %}
        {% endif %}

        # Move to the right side of the brush
        {% if brush_offset < 0 %} # brush center biased towards 0
            G1 X+{ brush_size/2 } F{Sc}
        {% else %}                # brush center biased towards x_max
            G1 X+{ (brush_size/2) - brush_offset} F{Sc}
        {% endif %}

        # Brush procedure
        {% for wipe in range(brushes) %}
            G1 X-{ (brush_size) - brush_offset } F{Sc}
            G1 X+{ (brush_size) - brush_offset } F{Sc}
        {% endfor %}

        G90

        # Reset acceleration values to what it was before
        SET_VELOCITY_LIMIT ACCEL={saved_accel}

        {% if purgeclean_servo_enabled %}
            _SERVO_RETRACT ITEM="clean"
        {% endif %}
    {% endif %}

    STATUS_LEDS COLOR="READY"

# ═══════════════════════════════════════════════════════

[gcode_macro PURGE]
description: Purge a specific amount of filament ontop of the purge bucket
gcode:
    {% set DISTANCE = params.DISTANCE|default(printer["gcode_macro _USER_VARIABLES"].purge_distance)|int %}
    {% set OOZE_TIME = params.OOZE_TIME|default(printer["gcode_macro _USER_VARIABLES"].purge_ooze_time)|int %}
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set Z_DROP = params.Z_DROP|default(1)|int %}

    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set purgeclean_servo_enabled = printer["gcode_macro _USER_VARIABLES"].purgeclean_servo_enabled %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if purge_and_brush_enabled %}
        {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
        {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
        
        STATUS_LEDS COLOR="CLEANING"
        
        RESPOND MSG="Purge filament..."

        {% if filament_sensor_enabled %}
            {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
                SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
                {% set re_enable_filament_sensor = 1 %}
            {% endif %}
        {% endif %}

        G90

        _CONDITIONAL_MOVE_TO_PURGE_BUCKET Z_DROP={Z_DROP}

        # Heat if needed and purge
        _LOW_TEMP_CHECK T={TEMP}
        G92 E0
        G1 E{DISTANCE|float} F150

        # Retract
        G92 E0
        G1 E-1.7 F2100
        G1 E-18.3 F150
        G92 E0

        # Wait some time to let the nozzle ooze before cleaning
        # No M400 needed here since G4 is also flushing Klipper's buffer
        G4 P{OOZE_TIME * 1000}

        {% if filament_sensor_enabled and re_enable_filament_sensor %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        {% endif %}

        {% if purgeclean_servo_enabled %}
            _SERVO_RETRACT ITEM="purge"
        {% endif %}
    {% endif %}

    STATUS_LEDS COLOR="READY"

# ═══════════════════════════════════════════════════════

[gcode_macro _CONDITIONAL_MOVE_TO_PURGE_BUCKET]
description: Move over the purge bucket
gcode:
    {% set Z_DROP = params.Z_DROP|default(1)|int %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set purgeclean_servo_enabled = printer["gcode_macro _USER_VARIABLES"].purgeclean_servo_enabled %}
    {% set Px, Py, Pz = printer["gcode_macro _USER_VARIABLES"].purge_bucket_xyz|map('float') %}

    # Move to purge zone only if it's available, else just purge where the toolhead is
    {% if purge_and_brush_enabled %}
        SAVE_GCODE_STATE NAME=CONDITIONAL_MOVE_TO_PURGE_BUCKET_STATE
        G90

        {% if Z_DROP == 1 %}
            G1 X{Px} Y{Py} F{St}
            G1 Z{Pz} F{St}
        {% else %}
            # If Z_DROP=0 there is probably some parts on the bed: we do not move the
            # Z axis and purge from an higher position. Also it's risky to use the
            # servo, so better to not do it here...
            G1 X{Px} Y{Py} F{St}
        {% endif %}

        RESTORE_GCODE_STATE NAME=CONDITIONAL_MOVE_TO_PURGE_BUCKET_STATE
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro M109]
rename_existing: M109.1
gcode:
    {% set S = params.S|float %}
    {% set actual_temp = printer.extruder.temperature|float %}

    {% set fix_heaters_temperature_settle = printer["gcode_macro _USER_VARIABLES"].fix_heaters_temperature_settle %}

    {% if fix_heaters_temperature_settle %}
        M104 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
        {% if S != 0 %}
            {% if actual_temp <= S %}
                TEMPERATURE_WAIT SENSOR=extruder MINIMUM={S}
            {% else %}
                TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={S}
            {% endif %}   
        {% endif %}
    {% else %}
        M109.1 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro HEATSOAK_CHAMBER]
description: Heatsoak chamber to a specific temperature with a timeout
gcode:
    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}

    {% if chamber_sensor_enabled %}
        {% set SETPOINT_TEMP = params.TEMP|default(0)|float %}
        {% set MAXTIME = params.MAXTIME|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_max_heating_time)|int %}


        {% for _ in range(1, MAXTIME) %}
            _WAIT_CHAMBER_TEMP TEMP={SETPOINT_TEMP}
        {% endfor %}
        
        RESPOND MSG="Chamber temperature OK or timeout reached!"

    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _WAIT_CHAMBER_TEMP]
# This macro is needed to allow klipper populate a new value in the printer[...].temperature variable as each variables are populated only once at the beginning of every macro call
gcode:
    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}

    {% if chamber_sensor_enabled %}
        {% set chamber_sensor_name = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_name %}
        {% set SETPOINT_TEMP = params.TEMP|default(0)|float %}
        {% set CURRENT_TEMP = printer["temperature_sensor " ~ chamber_sensor_name].temperature|float %}

        {% if CURRENT_TEMP <= SETPOINT_TEMP %}
            RESPOND MSG="Heating up the chamber : {CURRENT_TEMP}/{SETPOINT_TEMP}"
            G4 P{60000 * 1} # wait a minute and check again if called in a loop
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro HEATSOAK_BED]
description: Heatsoak bed at specified temperature and wait for a specific amount of time
gcode:
    {% set SETPOINT_TEMP = params.TEMP|default(0)|int %}
    {% set TIME = params.SOAKTIME|default(8)|int %}
    {% set heaterbed_enabled = printer["gcode_macro _USER_VARIABLES"].heaterbed_enabled %}
    {% set heatsoak_bed_enabled = printer["gcode_macro _USER_VARIABLES"].print_default_soak > 0 %} # configured heatsoak default value


    {% if heaterbed_enabled %}
        RESPOND MSG="Heating up bed..."


        M190 S{SETPOINT_TEMP}

        {% if TIME > 0 %}
            {% for i in range(0, TIME) %}
                RESPOND MSG="Heatsoak bed, {TIME-i}mn left..."
                G4 P{60000 * 1}
            {% endfor %}
        {% else %}
            {% if heatsoak_bed_enabled %}
                RESPOND MSG="No heatsoak needed, continue"
            {% endif %}
        {% endif %}

        RESPOND MSG="Bed temperature OK"
    
    {% else %}
        RESPOND MSG="No bed heater defined: nothing to do, continuing..."
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro CHANGE_FILAMENT]
description: Do a PAUSE, park the toolhead over the purge bucket and unload the filament
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}


    SAVE_GCODE_STATE NAME=CHANGE_FILAMENT_state
    PAUSE
    _CONDITIONAL_MOVE_TO_PURGE_BUCKET Z_DROP=0
    UNLOAD_FILAMENT TEMP={TEMP} DISTANCE={DISTANCE}
    RESTORE_GCODE_STATE NAME=CHANGE_FILAMENT_state

# ═══════════════════════════════════════════════════════

[gcode_macro UNLOAD_FILAMENT]
description: Basic unload of the filament (used with M600/CHANGE_FILAMENT)
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            RESPOND MSG="Runout sensor deactivated to unload filament"
        {% endif %}
    {% endif %}

    SAVE_GCODE_STATE NAME=UNLOAD_FILAMENT_state
    _LOW_TEMP_CHECK T={TEMP}

    _TIP_SHAPING
    M83
    G1 E-20 F3600
    G4 P3000
    G1 E{DISTANCE|float * -1} F3000

    # Flushing Klipper's buffer to ensure the unload is done before continuing
    M400

    RESTORE_GCODE_STATE NAME=UNLOAD_FILAMENT_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        RESPOND MSG="Filament unloaded, runout sensor reactivated"
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro LOAD_FILAMENT]
description: Basic load of the filament (used with M600/CHANGE_FILAMENT)
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set DISTANCE = params.DISTANCE|default(105)|float %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            RESPOND MSG="Runout sensor deactivated to load filament"
        {% endif %}
    {% endif %}

    SAVE_GCODE_STATE NAME=LOAD_FILAMENT_state
    _LOW_TEMP_CHECK T={TEMP}
    M83
    G92 E0
    G1 E{DISTANCE|float} F200
    G1 E50 F150

    # Flushing Klipper's buffer to ensure the load is done before continuing
    M400

    G92 E0
    RESTORE_GCODE_STATE NAME=LOAD_FILAMENT_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        RESPOND MSG="Filament loaded, runout sensor reactivated"
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _TIP_SHAPING]
description: Filament tip shaping sequence
gcode:
    {% set TEMP = params.TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set re_enable_filament_sensor = 0 %}

    {% if filament_sensor_enabled %}
        {% if (printer['filament_motion_sensor runout_sensor'] is defined and printer['filament_motion_sensor runout_sensor'].enabled) or (printer['filament_switch_sensor runout_sensor'] is defined and printer['filament_switch_sensor runout_sensor'].enabled) %}
            SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=0
            {% set re_enable_filament_sensor = 1 %}
            RESPOND MSG="Runout sensor deactivated for filament tip shaping"
        {% endif %}
    {% endif %}

    SAVE_GCODE_STATE NAME=TIP_SHAPING_state
    _LOW_TEMP_CHECK T={TEMP}

    {% set old_pressure_advance = printer.extruder.pressure_advance|default(0) %} # old pressure advance
    # we suppress pressure advance
    SET_PRESSURE_ADVANCE ADVANCE=0

    M82
    G92 E0
    G1 E2 F3600
    G1 E0 F3600
    G1 E3 F3600
    G1 E0 F3600
    G1 E4 F3600
    G1 E0 F3600

    # set last pressure advance
    SET_PRESSURE_ADVANCE ADVANCE={old_pressure_advance}

    # Flushing Klipper's buffer to ensure the tip shaping sequence is done before continuing
    M400

    RESTORE_GCODE_STATE NAME=TIP_SHAPING_state

    {% if filament_sensor_enabled and re_enable_filament_sensor %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
        RESPOND MSG="Filament tip shaping done, runout sensor reactivated"
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro M190]
rename_existing: M190.1
gcode:
    {% set S = params.S|float %}
    {% set actual_temp = printer.heater_bed.temperature|float %}

    {% set fix_heaters_temperature_settle = printer["gcode_macro _USER_VARIABLES"].fix_heaters_temperature_settle %}

    {% if fix_heaters_temperature_settle %}
        M140 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
        {% if S != 0 %}
            {% if actual_temp <= S %}
                TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={S}
            {% else %}
                TEMPERATURE_WAIT SENSOR=heater_bed MAXIMUM={S}
            {% endif %}   
        {% endif %}
    {% else %}
        M190.1 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro START_FILTER]
gcode:
    {% set SPEED = params.SPEED|default(1)|float %}
    {% set filter_name = printer["gcode_macro _USER_VARIABLES"].filter_name %}
    SET_FAN_SPEED FAN={filter_name} SPEED={SPEED}

# ═══════════════════════════════════════════════════════

[gcode_macro STOP_FILTER]
gcode:
    {% set filter_name = printer["gcode_macro _USER_VARIABLES"].filter_name %}
    SET_FAN_SPEED FAN={filter_name} SPEED=0

# ═══════════════════════════════════════════════════════

[delayed_gcode _STOP_FILTER_DELAYED]
gcode:
    STOP_FILTER

# ═══════════════════════════════════════════════════════

[gcode_macro LIGHT_OFF]
gcode:
    {% set light_pin_name = printer["gcode_macro _USER_VARIABLES"].light_pin_name %}
    set_pin pin={light_pin_name} value=0

# ═══════════════════════════════════════════════════════

[gcode_macro LIGHT_ON]
gcode:
    {% set S = params.S|default(100)|float %}
    {% set light_pin_name = printer["gcode_macro _USER_VARIABLES"].light_pin_name %}
    set_pin pin={light_pin_name} value={S}

# ═══════════════════════════════════════════════════════

[gcode_macro M701]
description: Map M701 to LOAD_FILAMENT
gcode:
    LOAD_FILAMENT

# ═══════════════════════════════════════════════════════

[gcode_macro M702]
description: Map M702 to UNLOAD_FILAMENT
gcode:
    UNLOAD_FILAMENT

# ═══════════════════════════════════════════════════════

[gcode_macro M600]
description: Map M600 to CHANGE_FILAMENT
gcode:
    CHANGE_FILAMENT

# ═══════════════════════════════════════════════════════

[gcode_macro M125]
description: Map M125 to PARK
gcode:
    PARK

# ═══════════════════════════════════════════════════════

[gcode_macro M900]
description: Map M900 to SET_PRESSURE_ADVANCE
gcode:
    {% if 'K' in params %}
        {% if 'E' in params %}
            SET_PRESSURE_ADVANCE EXTRUDER={params.E} ADVANCE={params.K}
        {% else %}
            SET_PRESSURE_ADVANCE ADVANCE={params.K}
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro M204]
description: Map M204 to SET_VELOCITY_LIMIT for ACCEL
rename_existing: M204.1
gcode:
    {% if 'S' in params %}
        {% set S = params.S|float %}
        SET_VELOCITY_LIMIT ACCEL={S}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro M205]
description: Map M205 to SET_VELOCITY_LIMIT for SQUARE_CORNER_VELOCITY
gcode:
    {% if 'X' in params %}
        SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY={params.X}
    {% elif 'Y' in params %}
        SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY={params.Y}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro G00]
gcode:  
    G0 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}

# ═══════════════════════════════════════════════════════

[gcode_macro G01]
gcode: 
    G1 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}

# ═══════════════════════════════════════════════════════

[gcode_macro G02]
gcode: 
    G2 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}

# ═══════════════════════════════════════════════════════

[gcode_macro G03]
gcode: 
    G2 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}

# ═══════════════════════════════════════════════════════

[gcode_macro G04]
gcode: 
    G4 {% for p in params %}{'%s%s' % (p, params[p])}{% endfor %}

# ═══════════════════════════════════════════════════════

[gcode_macro START_PRINT]
description: Machine heatup procedure before starting a print
variable_bed_temp: 0
variable_extruder_temp: 0
variable_z_adjust: 0
variable_soak: 0
variable_chamber_temp: 0
variable_chamber_maxtime: 0
variable_initial_tool: 0
variable_check_gates: 0
variable_tools_used: ""
variable_fl_size: "0_0_0_0"
variable_bed_mesh_profile: ""
variable_total_layer: 0
variable_adaptive_primeline: 1
gcode:
    # Get all the parameters passed from the slicer
    {% set BED_TEMP = params.BED_TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_bed_temp)|float %} # Bed temperature
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(printer["gcode_macro _USER_VARIABLES"].print_default_extruder_temp)|float %} # Extruder temperature
    {% set Z_ADJUST = params.Z_ADJUST|default(0)|float %}  # Optionnal Z adjustement from the slicer profile (ex. use it if you have textured vs smooth slicer profiles) 
    {% set SOAK = params.SOAK|default(printer["gcode_macro _USER_VARIABLES"].print_default_soak)|int %} # Heatsoak time of the bed in minutes
    {% set CHAMBER_TEMP = params.CHAMBER|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_temp)|int %} # Chamber temperature setpoint
    {% set CHAMBER_MAXTIME = params.CHAMBER_MAXTIME|default(printer["gcode_macro _USER_VARIABLES"].print_default_chamber_max_heating_time)|int %} # Chamber heatsoak timeout in minutes
    {% set INITIAL_TOOL = params.INITIAL_TOOL|default(0)|int %} # Initial tool (for the MMU/ERCF initialization)
    {% set MATERIAL = params.MATERIAL|default(printer["gcode_macro _USER_VARIABLES"].print_default_material)|string %} # Material type set in the slicer
    {% set FL_SIZE = params.SIZE|default("0_0_0_0")|string %} # Get bounding box of the first layer for the adaptive bed mesh
    {% set BED_MESH_PROFILE = params.MESH|default("")|string %} # Bed mesh profile to load
    {% set ADAPTIVE_PRIMELINE = params.ADAPTIVE_PRIMELINE|default(1)|int %} # Weither to do or not an adaptive prime line near the real print zone

    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=bed_temp VALUE={BED_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=extruder_temp VALUE={EXTRUDER_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=soak VALUE={SOAK}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=chamber_temp VALUE={CHAMBER_TEMP}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=chamber_maxtime VALUE={CHAMBER_MAXTIME}
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=fl_size VALUE='"{FL_SIZE}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=bed_mesh_profile VALUE='"{BED_MESH_PROFILE}"'
    SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=adaptive_primeline VALUE={ADAPTIVE_PRIMELINE}
    
    {% if params.TOTAL_LAYER %} # total layers count (if provided by the slicer)
        SET_PRINT_STATS_INFO TOTAL_LAYER={params.TOTAL_LAYER|int}
        SET_GCODE_VARIABLE MACRO=START_PRINT VARIABLE=total_layer VALUE={params.TOTAL_LAYER|int}
    {% endif %}

    # Get all the config options and configurations for this macro
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set light_intensity_start_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_start_print %}
    {% set light_intensity_printing = printer["gcode_macro _USER_VARIABLES"].light_intensity_printing %}
    {% set force_homing_in_start_print = printer["gcode_macro _USER_VARIABLES"].force_homing_in_start_print %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set part_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].part_fan_tach_enabled %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}
    {% set filter_speed_printing = printer["gcode_macro _USER_VARIABLES"].filter_speed_printing %}

    RESPOND MSG="Printing with '{MATERIAL}'"
    STATUS_LEDS COLOR="BUSY"
    LIGHT_ON S={light_intensity_start_print}
    CLEAR_PAUSE
    BED_MESH_CLEAR

    UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION=0
    STOP_FILTER

    # If a tachometer is enabled on one of the fans, we check them:
    #   - It's done only once for the part fan to be sure nothing block it before starting the print
    #   - And as a safety feature, we start a monitoring loop for the hotend fan (that is automatically stopped at the end of a print)
    {% if part_fan_tach_enabled %}
        M106 S255
        G4 P2000
        _PART_FAN_CHECK
        M106 S0
    {% endif %}

    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=1
    {% endif %}

    SET_GCODE_OFFSET Z=0
    M221 S100
    M220 S100
    G90
    M83

    # Homing before START_PRINT movements and actions
    {% if force_homing_in_start_print %}
        G28
    {% else %}
        _CG28
    {% endif %}

    # Here is the core of the START_PRINT were we get the startprint_actions variable
    # to do the procedure in the correct order for the configured probe (or user custom override)
    {% set sp_actions = printer["gcode_macro _USER_VARIABLES"].startprint_actions %}
    {% for action in sp_actions %}
        {% if action == "bed_soak" %}
            _MODULE_HEATSOAK_BED
        {% elif action == "chamber_soak" %}
            _MODULE_HEATSOAK_CHAMBER
        {% elif action == "tilt_calib" %}
            _MODULE_TILTING
        {% elif action == "extruder_heating" %}
            _MODULE_EXTRUDER_HEATING
        {% elif action == "purge" %}
            _MODULE_PURGE
        {% elif action == "clean" %}
            _MODULE_CLEAN
        {% elif action == "z_offset" %}
            _MODULE_Z_CALIB
        {% elif action == "bedmesh" %}
            _MODULE_BED_MESH
        {% elif action == "primeline" %}
            _MODULE_PRIMELINE
        {% elif action == "extruder_preheating" %}
            _MODULE_EXTRUDER_PREHEATING
        {% else %}
            { action_raise_error("Unknown module called in START_PRINT! Please verify your startprint_actions variable override!") }
        {% endif %}
    {% endfor %}

    # Fine adjustement of z offset (from the slicer profile). This is used to do a custom adjustement
    # when using textured/smooth PEI sheets, or for a special material from the slicer, etc...
    SET_GCODE_OFFSET Z_ADJUST={Z_ADJUST} MOVE=1

    START_FILTER SPEED={filter_speed_printing / 100}

    STATUS_LEDS COLOR="PRINTING"
    LIGHT_ON S={light_intensity_printing}
    RESPOND MSG="Printing"
    G92 E0.0

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_PRIMELINE]
gcode:
    # ----- PRIME LINE -------------------------------------------
    {% set FL_SIZE = printer["gcode_macro START_PRINT"].fl_size %}
    {% set ADAPTIVE_PRIMELINE = printer["gcode_macro START_PRINT"].adaptive_primeline %}

    RESPOND MSG="Executing a primeline..."

    PRIMELINE SIZE={FL_SIZE} ADAPTIVE_MODE={ADAPTIVE_PRIMELINE}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_HEATSOAK_BED]
gcode:
    # ----- BED HEATSOAK -------------------------------------
    # Heatsoak the bed if SOAK time is set and bed is not already warming up to the correct temperature (+-8°C).
    # We make the assumption that the soak is not needed if the bed is already at the correct target.
    # We also use the recirculating filter under the bed (if available) at full power to spread the heat
    # during the heatsoak if a specific temperature need to be reached.
    {% set BED_TEMP = printer["gcode_macro START_PRINT"].bed_temp %}
    {% set SOAK = printer["gcode_macro START_PRINT"].soak %}
    {% set CHAMBER_TEMP = printer["gcode_macro START_PRINT"].chamber_temp %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    STATUS_LEDS COLOR="HEATING"

    {% if printer.heater_bed.temperature < (BED_TEMP - 8) %}
        # If the machine is equiped by a chamber temperature sensor and a recirculating filter (check is automatic under the hood),
        # then we look if a specific chamber temperature is needed and we power on the recirculating filter to spread the heat
        {% if (CHAMBER_TEMP > 0) and filter_enabled %}
            START_FILTER SPEED=1
        {% endif %}

        # If we need a full soak (not 0 min), then move the toolhead to the center front to spread the heat using the hotend fan
        {% if SOAK > 0 %}
            G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}
        {% endif %}
    
        # Put the bed temperature target and wait for the soak
        HEATSOAK_BED TEMP={BED_TEMP} SOAKTIME={SOAK}
    {% else %}
        HEATSOAK_BED TEMP={BED_TEMP} SOAKTIME=0
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_HEATSOAK_CHAMBER]
gcode:
    # ----- CHAMBER HEATSOAK ----------------------------------
    # If a setpoint is defined and a sensor available, then we wait to reach the chamber temperature (with a timeout in case it's winter...)
    # If there is one, the recirculating filter is also be powered on from the previous step and kept like that to act as bed fans
    {% set CHAMBER_TEMP = printer["gcode_macro START_PRINT"].chamber_temp %}
    {% set CHAMBER_MAXTIME = printer["gcode_macro START_PRINT"].chamber_maxtime %}

    {% set chamber_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_enabled %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}

    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    {% if chamber_sensor_enabled %}
        {% if CHAMBER_TEMP > 0 %}
            {% set chamber_sensor_name = printer["gcode_macro _USER_VARIABLES"].chamber_temperature_sensor_name %}
            {% set CURRENT_TEMP = printer["temperature_sensor " ~ chamber_sensor_name].temperature|float %}

            # We do a first test to validate that the chamber is not already at temperature before starting the soak
            {% if CURRENT_TEMP <= CHAMBER_TEMP %}
                G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}

                # Start the filter (if available) to spread the heat faster in the chamber
                {% if filter_enabled %}
                    START_FILTER SPEED=1
                {% endif %}

                # Wait for the temperature of the chamber to be reached (default max: 15min)
                HEATSOAK_CHAMBER TEMP={CHAMBER_TEMP} MAXTIME={CHAMBER_MAXTIME}

                # Reset the filter status now that the chamber is at correct temperature
                {% if filter_enabled %}
                    STOP_FILTER
                {% endif %}
            {% endif %}
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_TILTING]
gcode:
    {% set force_homing_in_start_print = printer["gcode_macro _USER_VARIABLES"].force_homing_in_start_print %}
    _TILT_CALIBRATE FORCE={force_homing_in_start_print}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_EXTRUDER_HEATING]
gcode:
    {% set EXTRUDER_TEMP = printer["gcode_macro START_PRINT"].extruder_temp %}
    {% set INITIAL_TOOL = printer["gcode_macro START_PRINT"].initial_tool %}
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Px, Py, Pz = printer["gcode_macro _USER_VARIABLES"].purge_bucket_xyz|map('float') %}
    {% set max_x = printer.toolhead.axis_maximum.x|float %}
    {% set max_y = printer.toolhead.axis_maximum.y|float %}

    STATUS_LEDS COLOR="HEATING"

    RESPOND MSG="Extruder heating to print temperature..."

    _CONDITIONAL_MOVE_TO_PURGE_BUCKET
    {% if not purge_and_brush_enabled %}
        G0 X{max_x|int / 2} Y{max_y|int / 3} Z50 F{St}
    {% endif %}

    M109 S{EXTRUDER_TEMP}

    RESPOND MSG="Extruder temperature OK"

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_PURGE]
gcode:
    {% set EXTRUDER_TEMP = printer["gcode_macro START_PRINT"].extruder_temp %}
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}

    {% if purge_and_brush_enabled %}
        PURGE TEMP={EXTRUDER_TEMP}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_CLEAN]
gcode:
    # ----- PURGE AND CLEAN ---------------------------------
    # Just put the nozzle on the brush and clean it. Keep in mind that it's better to do
    # it with the hotend at material temperature but you can also do it at any time if needed
    {% set purge_and_brush_enabled = printer["gcode_macro _USER_VARIABLES"].purge_and_brush_enabled %}
    {% set force_homing_before_brush = printer["gcode_macro _USER_VARIABLES"].force_homing_before_brush %}

    {% if purge_and_brush_enabled %}
        {% if force_homing_before_brush %}
            G28 Z # perform homing before going to the brush to avoid a miss or crash
        {% endif %}
        CLEAN_NOZZLE
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_Z_CALIB]
gcode:
    G28 Z

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_BED_MESH]
gcode:
    # ----- BED MESH -------------------------------------------
    {% set FL_SIZE = printer["gcode_macro START_PRINT"].fl_size %}
    {% set BED_MESH_PROFILE = printer["gcode_macro START_PRINT"].bed_mesh_profile %}

    {% if BED_MESH_PROFILE == "" %}
        RESPOND MSG="Bed mesh measurement..."
        ADAPTIVE_BED_MESH SIZE={FL_SIZE}
    {% else %}
        RESPOND MSG="Load bed mesh profile : {BED_MESH_PROFILE}"
        BED_MESH_PROFILE LOAD={BED_MESH_PROFILE}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _MODULE_EXTRUDER_PREHEATING]
gcode:
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}

    STATUS_LEDS COLOR="HEATING"
    RESPOND MSG="Pre-heating the nozzle to a safe temperature..."
    M109 S{safe_extruder_temp}
    RESPOND MSG="Extruder at safe temperature of {safe_extruder_temp}°C"      

# ═══════════════════════════════════════════════════════

[gcode_macro PAUSE]
rename_existing: BASE_PAUSE
description: Pause the print and park
gcode:
    {% set light_intensity_start_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_start_print %}

    {% if printer.pause_resume.is_paused %}
        RESPOND MSG="Print is already paused"
    {% else %}
        SAVE_GCODE_STATE NAME=PAUSE_state
        LIGHT_ON S={light_intensity_start_print}
        BASE_PAUSE
        PARK
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro RESUME]
rename_existing: BASE_RESUME
description: Resume the print after an optional unretract
gcode:
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed %}
    {% set light_intensity_printing = printer["gcode_macro _USER_VARIABLES"].light_intensity_printing %}

    {% if not printer.pause_resume.is_paused %}
        RESPOND MSG="Print is not paused. Resume ignored"
    {% else %}
        RESTORE_GCODE_STATE NAME=PAUSE_state MOVE=1 MOVE_SPEED={St}
        LIGHT_ON S={light_intensity_printing}
        BASE_RESUME
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro PARK]
description: Park the toolhead at the back and retract some filament if the nozzle is hot
gcode:
    {% set Px, Py = printer["gcode_macro _USER_VARIABLES"].park_position_xy|map('float') %}
    {% set Px = params.X|default(Px)|float %}
    {% set Py = params.Y|default(Py)|float %}
    
    {% set park_lift_z = printer["gcode_macro _USER_VARIABLES"].park_lift_z %}
    {% set Z_HOP = params.Z_HOP|default(park_lift_z)|float %}

    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    {% set max_z = printer.toolhead.axis_maximum.z - printer.gcode_move.homing_origin.z |float %}
    {% set act_z = printer.toolhead.position.z|float %}

    {% set z_safe = act_z + Z_HOP %}
    {% if z_safe > max_z %}
        {% set z_safe = max_z %}
    {% endif %}

    {% if printer.toolhead.homed_axes != "xyz" %}
        {action_raise_error("Cannot park the toolhead because axis are not homed!")}
    {% endif %}
    
    SAVE_GCODE_STATE NAME=PARK

    {% if printer.extruder.can_extrude %}
        {% if params.E is defined %}
            {% set E = params.E|float|abs %}
            RESPOND MSG="Retraction overrided with parameter, Extruder retraction = {E}"

        {% else %}
            {% set E = 1.7 %}
            RESPOND MSG="Extruder retraction = {E}"

        {% endif %}

        {% if E is defined and E > 0 %}
            G92 E0
            G1 E-{E} F2100
        {% endif %}
    {% endif %}

    G90
    G1 Z{z_safe} F{Sz}
    G0 X{Px} Y{Py} F{St}
    
    RESTORE_GCODE_STATE NAME=PARK

# ═══════════════════════════════════════════════════════

[gcode_macro PARK_FRONT]
description: Park the toolhead on the front of the printer for maintenance
gcode:
    {% set St = printer["gcode_macro _USER_VARIABLES"].travel_speed * 60 %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    {% if printer.toolhead.homed_axes != "xyz" %}
        {action_raise_error("Cannot park the toolhead in maintenance position because axis are not homed!")}
    {% endif %}

    SAVE_GCODE_STATE NAME=PARK_FRONT

    G90      ; absolute positioning
    G0 Z{printer.toolhead.axis_maximum.z/3*2} F{Sz}
    G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+10} F{St}

    RESTORE_GCODE_STATE NAME=PARK_FRONT

# ═══════════════════════════════════════════════════════

[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
description: Cancel the print, retract 10mm of filament and park
gcode:
    {% set turn_off_heaters_in_end_print = printer["gcode_macro _USER_VARIABLES"].turn_off_heaters_in_end_print %}
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}
    {% set light_intensity_end_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_end_print %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filter_time = printer["gcode_macro _USER_VARIABLES"].filter_time|default(600)|int %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}
    
    {% set variable_filter_name = printer["gcode_macro _USER_VARIABLES"].variable_filter_name %}

    PARK

    {% if printer.extruder.can_extrude %}
        G92 E0
        G1 E-10 F2100
    {% endif %}

    {% if turn_off_heaters_in_end_print %}
        TURN_OFF_HEATERS
    {% else %}
        SET_HEATER_TEMPERATURE HEATER=extruder TARGET={safe_extruder_temp}
    {% endif %}

    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=0
    {% endif %}

    M107
    M400
    CLEAR_PAUSE

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    SDCARD_RESET_FILE

    {% if printer['fan_generic filter'].speed > 0 %}
        {% set FILTER_TIME = params.FILTER_TIME|default(filter_time)|int %}
        START_FILTER SPEED=1
        UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION={FILTER_TIME}
    {% endif %}

    LIGHT_ON S={light_intensity_end_print}
    STATUS_LEDS COLOR="OFF"
    BASE_CANCEL_PRINT

# ═══════════════════════════════════════════════════════

[gcode_macro _OFF]
description: Turn off the printer
gcode:
    M84                                                             ; turn steppers off
    TURN_OFF_HEATERS                                                ; turn bed / hotend off
    M107                                                            ; turn print cooling fan off
    LIGHT_OFF                                                   ; turn off light
    STATUS_LEDS COLOR="SHUTDOWN"                                     ; turn off status LEDs

# ═══════════════════════════════════════════════════════

[gcode_macro SHUTDOWN]
description: Turn off the printer and shutdown the host
gcode:
    _OFF                                               ; Shortcut to turn everything off (see above for this macro)
    {action_respond_info('action:poweroff')}          ; OctoPrint compatible host shutdown
	{action_call_remote_method("shutdown_machine")}   ; Moonraker compatible host shutdown

# ═══════════════════════════════════════════════════════

[gcode_macro END_PRINT]
description: Stop the print and filter the atmosphere for 10min before shuting down
gcode:
    {% set disable_motors_in_end_print = printer["gcode_macro _USER_VARIABLES"].disable_motors_in_end_print %}
    {% set turn_off_heaters_in_end_print = printer["gcode_macro _USER_VARIABLES"].turn_off_heaters_in_end_print %}
    {% set safe_extruder_temp = printer["gcode_macro _USER_VARIABLES"].safe_extruder_temp|float %}
    {% set light_intensity_end_print = printer["gcode_macro _USER_VARIABLES"].light_intensity_end_print %}
    {% set filter_enabled = printer["gcode_macro _USER_VARIABLES"].filter_enabled %}
    {% set light_enabled = printer["gcode_macro _USER_VARIABLES"].light_enabled %}
    {% set bed_mesh_enabled = printer["gcode_macro _USER_VARIABLES"].bed_mesh_enabled %}
    {% set filter_time = printer["gcode_macro _USER_VARIABLES"].filter_time|default(600)|int %}
    {% set filament_sensor_enabled = printer["gcode_macro _USER_VARIABLES"].filament_sensor_enabled %}
    {% set hotend_fan_tach_enabled = printer["gcode_macro _USER_VARIABLES"].hotend_fan_tach_enabled %}

    PARK

    {% if printer.extruder.can_extrude %}
        # pull back the filament a little bit
        G92 E0
        G1 E-10 F2100
    {% endif %}

    {% if turn_off_heaters_in_end_print %}
        TURN_OFF_HEATERS
    {% else %}
        SET_HEATER_TEMPERATURE HEATER=extruder TARGET={safe_extruder_temp}
    {% endif %}

    {% if hotend_fan_tach_enabled %}
        UPDATE_DELAYED_GCODE ID=_BACKGROUND_HOTEND_TACHO_CHECK DURATION=0
    {% endif %}

    M107
    M400

    {% if bed_mesh_enabled %}
        BED_MESH_CLEAR
    {% endif %}

    {% if disable_motors_in_end_print %}
        M84
    {% endif %}


    # If a filter is connected, and used during the print, continue filtering the air
    # for a couple of min before stopping everything
    {% if filter_enabled %}
        {% if printer['fan_generic filter'].speed > 0 %}
            {% set FILTER_TIME = params.FILTER_TIME|default(filter_time)|int %}
            START_FILTER SPEED=1
            UPDATE_DELAYED_GCODE ID=_STOP_FILTER_DELAYED DURATION={FILTER_TIME}
        {% endif %}
    {% endif %}

    {% if light_enabled %}
        LIGHT_ON S={light_intensity_end_print}
    {% endif %}
    STATUS_LEDS COLOR="DONE_PRINTING"

    # If a filament sensor is connected, re-enable it in case it was disabled during printing
    {% if filament_sensor_enabled %}
        SET_FILAMENT_SENSOR SENSOR="runout_sensor" ENABLE=1
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro BED_MESH_CALIBRATE]
rename_existing: _BASE_BED_MESH_CALIBRATE
description: Perform Mesh Bed Leveling with klicky automount
gcode:
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    { action_respond_info("Bed Mesh Calibrate") }
    _CG28
    ACTIVATE_PROBE
    _BASE_BED_MESH_CALIBRATE  {% for p in params %}{'%s=%s ' % (p, params[p])}{% endfor %}
    DEACTIVATE_PROBE

# ═══════════════════════════════════════════════════════

[gcode_macro QUAD_GANTRY_LEVEL]
rename_existing: _BASE_QUAD_GANTRY_LEVEL
description: Conform a moving, twistable gantry to the shape of a stationary bed with klicky automount
gcode:
    {% set tilting_travel_accel = printer["gcode_macro _USER_VARIABLES"].tilting_travel_accel %}

    { action_respond_info("Quad gantry leveling") }

    _CG28
    
    STATUS_LEDS COLOR="LEVELING"

    ACTIVATE_PROBE

    # Set the tilting acceleration prior to any movement
    {% set saved_accel = printer.toolhead.max_accel %}
    M204 S{tilting_travel_accel}

    _BASE_QUAD_GANTRY_LEVEL {% for p in params %}{'%s=%s ' % (p, params[p])}{% endfor %}
    
    # Reset acceleration values to what it was before
    SET_VELOCITY_LIMIT ACCEL={saved_accel}

    DEACTIVATE_PROBE

    STATUS_LEDS COLOR="READY"

# ═══════════════════════════════════════════════════════

[gcode_macro ACTIVATE_PROBE]
description: Put the machine in a state being able to probe
variable_temperature: 0
gcode:
    {% set LOCK = params.LOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_max_probing_temp = printer["gcode_macro _USER_VARIABLES"].tap_max_probing_temp|float %}

    # If a Voron TAP probe is defined, then check the temperature and lower it if needed
    {% elif probe_type_enabled == "vorontap" %}
        SAVE_GCODE_STATE NAME=BEFORE_TAP_ACTION

        {% set ACTUAL_TEMP = printer.extruder.temperature %}
        {% set TARGET_TEMP = printer.extruder.target %}

        SET_GCODE_VARIABLE MACRO=ACTIVATE_PROBE VARIABLE=temperature VALUE={TARGET_TEMP}

        {% if TARGET_TEMP > tap_max_probing_temp %}
            { action_respond_info('Extruder temperature target of %.1fC is too high for TAP probing, lowering to %.1fC' % (TARGET_TEMP, tap_max_probing_temp)) }
            M106 S255 ; 100% the part cooling fan to help the extruder cooling
            M109 S{tap_max_probing_temp}
            M106 S0   ; Stop the part cooling fan
        {% else %}
            # Temperature target is already low enough, but nozzle may still be too hot
            {% if ACTUAL_TEMP > tap_max_probing_temp + 3 %}
                M106 S255 ; 100% the part cooling fan to help the extruder cooling
                TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={tap_max_probing_temp}
                M106 S0   ; Stop the part cooling fan
            {% endif %}
        {% endif %}
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro DEACTIVATE_PROBE]
description: Revert the machine to a normal state after probing
gcode:
    {% set UNLOCK = params.UNLOCK|default(False, boolean=true) %}

    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}
    {% set tap_deactivation_zhop = printer["gcode_macro _USER_VARIABLES"].tap_deactivation_zhop %}
    {% set Sz = printer["gcode_macro _USER_VARIABLES"].z_drop_speed * 60 %}

    # If a Voron TAP probe is defined, then check and restore the nozzle temperature if needed
    {% elif probe_type_enabled == "vorontap" %}
        # Small Z hop to avoid restoring the temperature directly on the PEI
        {% set z_safe = printer.toolhead.position.z + tap_deactivation_zhop %}
        {% if z_safe > printer.toolhead.axis_maximum.z %}
            {% set z_safe = printer.toolhead.axis_maximum.z %}
        {% endif %}
        G90
        G1 Z{z_safe} F{Sz}

        # Then restoring the temperature
        {% set old_target_temperature = printer["gcode_macro ACTIVATE_PROBE"].temperature %}
        M109 S{old_target_temperature}

        RESTORE_GCODE_STATE NAME=BEFORE_TAP_ACTION
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _CG28]
description: Homing only if necessary
gcode:
    {% if "xyz" not in printer.toolhead.homed_axes %}
        STATUS_LEDS COLOR="HOMING"
        G28
        STATUS_LEDS COLOR="READY"
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _TILT_CALIBRATE]
description: Do a QGL, Z_tilt, etc... depending of the machine configuration
gcode:
    {% set FORCE_OPERATION = params.FORCE|default('true') %}
    {% set conf_QGL = printer["gcode_macro _USER_VARIABLES"].qgl_enabled %}
    {% set conf_ztilt = printer["gcode_macro _USER_VARIABLES"].ztilt_enabled %}
    {% set probe_type_enabled = printer["gcode_macro _USER_VARIABLES"].probe_type_enabled %}

    {% if conf_QGL %}
        {% if printer.quad_gantry_level.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            RESPOND MSG="QGL..."
            QUAD_GANTRY_LEVEL
        {% endif %}

    {% elif conf_ztilt %}
        {% if printer.z_tilt.applied|lower == 'false' or FORCE_OPERATION|lower == 'true' %}
            RESPOND MSG="Z tilt adjust..."
            Z_TILT_ADJUST
        {% endif %}

    {% else %}
        RESPOND MSG="No tilt calibration needed on this machine. Continuing..."
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _ADAPTIVE_MESH_VARIABLES]
variable_ready: False
variable_do_mesh: False
variable_do_nominal: False
variable_mesh_min: 0,0
variable_mesh_max: 0,0
variable_probe_count: 0,0
variable_algo: "bicubic"
gcode:

# ═══════════════════════════════════════════════════════

[gcode_macro COMPUTE_MESH_PARAMETERS]
description: Compute the mesh parameters and store them for later use
gcode:
    # 1 ----- GET ORIGINAL BEDMESH PARAMS FROM CONFIG ----------------------
    {% set xMinConf, yMinConf = printer["configfile"].config["bed_mesh"]["mesh_min"].split(',')|map('trim')|map('int') %}
    {% set xMaxConf, yMaxConf = printer["configfile"].config["bed_mesh"]["mesh_max"].split(',')|map('trim')|map('int') %}
    {% set xProbeCntConf, yProbeCntConf = printer["configfile"].config["bed_mesh"]["probe_count"].split(',')|map('trim')|map('int') %}
    {% set algo = printer["configfile"].config["bed_mesh"]["algorithm"]|lower %}
    {% set xMeshPPS, yMeshPPS = (printer["configfile"].config["bed_mesh"]["mesh_pps"]|default('2,2')).split(',')|map('trim')|map('int') %}

    {% set margin = params.MARGIN|default(5)|int %} # additional margin to mesh around the first layer
    {% set force_mesh = params.FORCE_MESH|default(False) %} # force the mesh even if it's a small part (ie. computed less than 3x3)


    # 2 ----- GET FIRST LAYER COORDINATES and SIZE -------------------------------------
    # If the SIZE parameter is defined and not a dummy placeholder, we use it to do the adaptive bed mesh logic
    {% set coordinatesFound = false %}
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}
        RESPOND MSG="Got a SIZE parameter for the adaptive bed mesh"
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set coordinatesFound = true %}

    {% elif printer.exclude_object is defined %}
        {% if printer.exclude_object.objects %}
            # Else if SIZE is not defined, we fallback to use the [exclude_object] tags
            # This method is derived from Kyleisah KAMP repository: https://github.com/kyleisah/Klipper-Adaptive-Meshing-Purging)
            RESPOND MSG="No SIZE parameter, using the [exclude_object] tags for the adaptive bed mesh"
            {% set eo_points = printer.exclude_object.objects|map(attribute='polygon')|sum(start=[]) %}
            {% set xMinSpec = eo_points|map(attribute=0)|min %}
            {% set yMinSpec = eo_points|map(attribute=1)|min %}
            {% set xMaxSpec = eo_points|map(attribute=0)|max %}
            {% set yMaxSpec = eo_points|map(attribute=1)|max %}
            {% set coordinatesFound = true %}
        {% endif %}
    {% endif %}

    {% if not coordinatesFound %}
        # If no SIZE parameter and no [exclude_object] tags, then we want to do a nominal bed mesh
        # so nothing to do here...
        RESPOND MSG="No info about the first layer coordinates, doing a nominal bed mesh instead of adaptive"
    {% endif %}


    # If the first layer size was correctly retrieved, we can do the adaptive bed mesh logic, else we
    # fallback to the original and nominal BED_MESH_CALIBRATE function (full bed probing)
    {% if xMinSpec and yMinSpec and xMaxSpec and yMaxSpec %}

        # 3 ----- APPLY MARGINS ----------------------------------------------
        # We use min/max function as we want it to be constrained by the original
        # bedmesh size. This will avoid going outside the machine limits
        {% set xMin = [xMinConf, (xMinSpec - margin)]|max %}
        {% set xMax = [xMaxConf, (xMaxSpec + margin)]|min %}
        {% set yMin = [yMinConf, (yMinSpec - margin)]|max %}
        {% set yMax = [yMaxConf, (yMaxSpec + margin)]|min %}

        # 4 ----- COMPUTE A NEW PROBE COUNT ----------------------------------
        # The goal is to have at least the same precision as from the config. So we compute an equivalent number
        # of probe points on each X/Y dimensions (distance between two points should be the same as in the config)
        {% set xProbeCnt = ((xMax - xMin) * xProbeCntConf / (xMaxConf - xMinConf))|round(0, 'ceil')|int %}
        {% set yProbeCnt = ((yMax - yMin) * yProbeCntConf / (yMaxConf - yMinConf))|round(0, 'ceil')|int %}

        # Then, three possibilities :
        # a) Both dimensions have less than 3 probe points : the bed_mesh is not needed as it's a small print (if not forced).
        # b) If one of the dimension is less than 3 and the other is greater. The print looks to be elongated and
        #    need the adaptive bed_mesh : we add probing points to the small direction to reach 3 and be able to do it.
        # c) If both direction are greater than 3, we need the adaptive bed_mesh and it's ok.
        # At the end we control (according to Klipper bed_mesh method: "_verify_algorithm") that the computed probe_count is
        # valid according to the choosen algorithm or change it if needed.
        {% if xProbeCnt < 3 and yProbeCnt < 3 %}
            {% if force_mesh %}
                RESPOND MSG="Bed mesh forced (small part detected): meshing 3x3..."
                {% set xProbeCnt = 3 %}
                {% set yProbeCnt = 3 %}
                {% set algo = "lagrange" %}
                {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
                {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
                {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
                RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
            {% else %}
                RESPOND MSG="Computed mesh parameters: none, bed mesh not needed for very small parts"
                SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={False}
            {% endif %}
        {% else %}
            {% set xProbeCnt = [3, xProbeCnt]|max %}
            {% set yProbeCnt = [3, yProbeCnt]|max %}

            # Check of the probe points and interpolation algorithms according to Klipper code
            {% if xMeshPPS != 0 or yMeshPPS != 0 %}
                {% set probeCntMin = [xProbeCnt, yProbeCnt]|min %}
                {% set probeCntMax = [xProbeCnt, yProbeCnt]|max %}
                {% if algo == "lagrange" and probeCntMax > 6 %}
                    # Lagrange interpolation tends to oscillate when using more than 6 samples: swith to bicubic
                    {% set algo = "bicubic" %}
                {% endif %}
                {% if algo == "bicubic" and probeCntMin < 4 %}
                    {% if probeCntMax > 6 %}
                        # Impossible case: need to add probe point on the small axis to be >= 4 (we want 5 to keep it odd)
                        {% if xProbeCnt > yProbeCnt %}
                            {% set yProbeCnt = 5 %}
                        {% else %}
                            {% set xProbeCnt = 5 %}
                        {% endif %}
                    {% else %}
                        # In this case bicubic is not adapted (less than 4 points): switch to lagrange
                        {% set algo = "lagrange" %}
                    {% endif %}
                {% endif %}
            {% endif %}

            # 5 ----- FORMAT THE PARAMETERS AND SAVE THEM ---------------------------
            {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
            {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
            {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
            RESPOND MSG="Computed mesh parameters: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={False}
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_min VALUE='"{mesh_min}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=mesh_max VALUE='"{mesh_max}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=probe_count VALUE='"{probe_count}"'
            SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=algo VALUE='"{algo}"'
        {% endif %}
    {% else %}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_mesh VALUE={True}
        SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=do_nominal VALUE={True}
    {% endif %}

    # Finaly save in the variables that we already computed the values
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={True}

# ═══════════════════════════════════════════════════════

[gcode_macro ADAPTIVE_BED_MESH]
description: Perform a bed mesh, but only where and when it's needed
gcode:
    {% set ready = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].ready %}

    {% if not 'xyz' in printer.toolhead.homed_axes %}
        { action_raise_error("Must Home printer first!") }
    {% endif %}

    # If the parameters where computed, we can do the mesh by calling the _DO_ADAPTIVE_MESH
    {% if ready %}
        _DO_ADAPTIVE_MESH

    # If the parameters where not computed prior to the ADAPTIVE_BED_MESH call, we call the COMPUTE_MESH_PARAMETERS
    # macro first and then call the _DO_ADAPTIVE_MESH macro after it
    {% else %}
        RESPOND MSG="Adaptive bed mesh: parameters not already computed, automatically calling the COMPUTE_MESH_PARAMETERS macro prior to the mesh"
        COMPUTE_MESH_PARAMETERS {rawparams}
        M400 # mandatory to flush the gcode buffer and be sure to use the last computed parameters
        _DO_ADAPTIVE_MESH
    {% endif %}

# ═══════════════════════════════════════════════════════

[gcode_macro _DO_ADAPTIVE_MESH]
gcode:
    # 1 ----- POPULATE BEDMESH PARAMS FROM SAVED VARIABLES ----------------------
    {% set do_mesh = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_mesh %}
    {% set do_nominal = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].do_nominal %}
    {% set mesh_min = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_min %}
    {% set mesh_max = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].mesh_max %}
    {% set probe_count = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].probe_count %}
    {% set algo = printer["gcode_macro _ADAPTIVE_MESH_VARIABLES"].algo %}

    # 2 --------- ADAPTIVE_BED_MESH LOGIC --------------------------------------

    # If it's necessary to do a mesh
    {% if do_mesh %}
        # If it's a standard bed_mesh to be done
        {% if do_nominal %}
            RESPOND MSG="Adaptive bed mesh: nominal bed mesh"
            BED_MESH_CALIBRATE
        {% else %}
                RESPOND MSG="Adaptive bed mesh: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}"
                BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}
        {% endif %}
    {% else %}
        RESPOND MSG="Adaptive bed mesh: no mesh to be done"
    {% endif %}

    # Set back the 'ready' parameter to false
    SET_GCODE_VARIABLE MACRO=_ADAPTIVE_MESH_VARIABLES VARIABLE=ready VALUE={False}